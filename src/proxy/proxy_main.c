#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <netdb.h>
#include <stdio.h>
#include <sys/epoll.h>

#include "backend/unix_conn.h"
#include "common/common.h"

#define BUFSIZE 4096

char buf[BUFSIZE];

int main(void) {
  char path[UNIX_PATH_MAX];
  size_t len;
  if (!find_server_addr(path, &len))
    die2("backend is not running");

  int us = socket(AF_UNIX, SOCK_STREAM, 0);
  if (us < 0) die("socket");
  struct sockaddr_un sa = { .sun_family = AF_UNIX };
  memcpy(sa.sun_path, path, len);
  sa.sun_path[0] = '\0';

  int on = 1;
  if (setsockopt(us, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on)) < 0)
    die("setsockopt");
  if (connect(us, (struct sockaddr*)&sa, sizeof(sa.sun_family) + len) < 0)
    die("connect");

  if (!unix_conn_verify_cred(us))
    die2("server has invalid credentials");

  int epfd = epoll_create1(0);
  struct epoll_event ee = { .events = EPOLLIN, .data.fd = us };
  if (epoll_ctl(epfd, EPOLL_CTL_ADD, us, &ee) < 0) die("epoll_ctl");

  ee.events = EPOLLIN;
  ee.data.fd = STDIN_FILENO;
  if (epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &ee) < 0) die("epoll_ctl");

  for (;;) {
    int nfd = epoll_wait(epfd, &ee, 1, -1);
    if (nfd < 0) die("epoll_wait");
    ssize_t nread = read(ee.data.fd, buf, BUFSIZE);
    if (nread < 0) die("read");
    if (nread == 0) break;
    int to = ee.data.fd == STDIN_FILENO ? us : STDOUT_FILENO;
    ssize_t nwrote = write(to, buf, nread);
    if (nwrote < 0) die("write");
    if (nwrote != nread) die2("partial write");
  }
  close(us);
}
